# 进程与线程

## **进程是内存分配的最小单位,线程是 CPU 调度的最小单位**

# 浏览器内核——浏览器渲染进程

1. GUI 渲染线程
   **解析 HTML,CSS 构建 DOM 树,render 树,布局绘制**
   **与 JS 引擎线程互斥**
2. JS 引擎线程
   **处理 js 代码,事件循环**
3. 定时器线程
   **setTimeout/setInterval 计时**
4. 事件线程
   **准备回调交给 js 引擎线程执行**
5. 异步线程

---

# 微任务&宏任务

1. 常见宏任务:I/O,UI 渲染,定时器,主线代码
2. 常见微任务:Promise,MutationObserver
3. 每执行一个宏任务都会清空微任务队列

---

# 缓存策略

1. 地址栏的缓存
   **HSTS(HTTP Strict Transport Security)强制客户端浏览器使用 https 协议与服务器创建连接**
2. DNS 缓存(DNS Prefetch)
   **让具有该属性的域名不用等用户点击就在后台解析**
3. ARP 缓存(Address Resolution Protocol)
   **储存 IP 地址和 MAC 地址的映射表**
4. TCP Buffer 区缓存

---

# 浏览器多进程架构

1. 进程
   1. 主进程:控制地址栏,书签,网络请求,文件访问
   1. UI 线程
   1. 网络线程
   1. 存储线程
   1. 渲染进程: 关于页面显示
   1. 插件进程: 网站使用的插件
   1. GPU 进程: 独立于其他进程处理 GPU 任务
2. 优点
   1. 互不影响
   2. 沙盒安全
   3. 整合成服务,节省资源
   4. 站点隔离
3. CORB
   **限制敏感资源进入渲染进程的内存**

---

# 一张网页的一生

1. 输入的 URL 被主进程的 UI 线程接管
2. UI 线程判断是字符串还是域名
3. 用户点击进入,UI 线程将域名交给网络线程,然后将进度条显示在选项卡上
4. 网络线程 DNS 找到 IP 并进行特定协议的链接
5. 网络线程获取到数据并对数据类型进行识别,如果是 HTML 文件就交给渲染进程,如果是下载请求就交给下载管理器,同时与恶意站点匹配,发出警告
6. 主进程将数据提交给渲染进程,同时地址栏更新
7. 渲染进程接收到 html 文件开始解析构成 DOM 树,同时 CSS 脚本等外部资源从缓存或者通知主进程的网络线程加载
8. 主线程解析 CSS,确定每个 DOM 元素的计算样式
9. 主线程遍历 DOM,计算样式,并创建布局树,布局树种包含 x,y 坐标和边界框大小
10. 确定绘制顺序,开始绘制
11. 光栅化
    **将布局树信息和绘制记录(顺序)信息转换成屏幕上的像素**
12. 将页面分层分别光栅化,当页面滑动时,重新在单独线程的合成器下合成新帧 2.遍历布局树,创建层树 3.主线程将层树信息提交给合成器线程 4.合成器线程将每个层分割成小的瓦片,交给栅格线程,栅格线程栅格化后储存在 GPU 内存中 5.合成器线程收集瓦片,创建合成器帧 6.合成器帧发送到 GPU,显示在屏幕上

---

# 浏览器事件与合成器

1. 浏览器事件由主进程捕获,主进程将位置信息和事件类型交给渲染进程处理
2. 采用合成器合成页面主要优势就是不用与主进程通信
3. 所以合成器在合成页面的时候会指定一个区域为"非快速可滑动区域",此区域可以处理事件,此区域之外不影响合成
